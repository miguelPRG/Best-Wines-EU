{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "52424c63",
   "metadata": {},
   "outputs": [],
   "source": [
    "# CÉLULA 0 – Instalar dependências automaticamente com uv (roda só uma vez)\n",
    "import os\n",
    "import subprocess\n",
    "import sys\n",
    "from pathlib import Path\n",
    "\n",
    "print(\"Instalando/atualizando dependências com uv...\")\n",
    "\n",
    "# 1. Instala o uv se ainda não existir\n",
    "try:\n",
    "    subprocess.run([\"uv\", \"--version\"], check=True, capture_output=True)\n",
    "    print(\"uv já está instalado\")\n",
    "except (subprocess.CalledProcessError, FileNotFoundError):\n",
    "    print(\"uv não encontrado → instalando agora...\")\n",
    "    subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"uv\"], check=True)\n",
    "\n",
    "# 2. Se houver pyproject.toml na pasta atual → sincroniza tudo com uv\n",
    "if Path(\"pyproject.toml\").exists():\n",
    "    print(\"pyproject.toml encontrado → instalando todas as dependências...\")\n",
    "    result = subprocess.run([\"uv\", \"sync\", \"--frozen\"], capture_output=True, text=True)\n",
    "    if result.returncode == 0:\n",
    "        print(\"Todas as dependências instaladas/atualizadas com sucesso!\")\n",
    "    else:\n",
    "        print(\"Erro no uv sync:\", result.stderr)\n",
    "else:\n",
    "    print(\"AVISO: pyproject.toml não encontrado – pula instalação automática\")\n",
    "\n",
    "# 3. (Opcional) Mostra as versões instaladas\n",
    "try:\n",
    "    subprocess.run([\"uv\", \"pip\", \"list\", \"--format=freeze\"], check=True)\n",
    "except:\n",
    "    pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ecc28d1d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 1 – Imports e estilo\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import plotly.express as px\n",
    "import folium\n",
    "from IPython.display import display, Markdown\n",
    "\n",
    "plt.style.use('seaborn-v0_8')\n",
    "sns.set_palette(\"viridis\")\n",
    "%matplotlib inline\n",
    "\n",
    "print(\"Bibliotecas importadas com sucesso!\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bfec40e7",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 2 – Carregar e preparar dados\n",
    "\n",
    "# Queremos apenas os vinhos de países da União Europeia\n",
    "eu_countries = ['Portugal','France','Italy','Spain','Germany','Austria','Greece','Hungary',\n",
    "                'Romania','Bulgaria','Croatia','Slovenia','Slovakia','Czech Republic','Poland',\n",
    "                'Cyprus','Malta','Belgium','Netherlands','Luxembourg','Ireland','Denmark',\n",
    "                'Sweden','Finland','Estonia','Latvia','Lithuania']\n",
    "\n",
    "df = pd.read_csv('./data/winemag-data-130k-v2.csv')\n",
    "df_eu = df[df['country'].isin(eu_countries)].copy()\n",
    "\n",
    "# Limpeza preço\n",
    "df_eu['price'] = df_eu.groupby('country')['price'].transform(lambda x: x.fillna(x.median()))\n",
    "df_eu['price'].fillna(df_eu['price'].median(), inplace=True)\n",
    "df_eu = df_eu[df_eu['price'] > 0].copy()\n",
    "\n",
    "# Qualidade/preço\n",
    "df_eu['points_per_euro'] = df_eu['points'] / df_eu['price']\n",
    "\n",
    "display(Markdown(f\"**Vinhos da UE analisados: {len(df_eu):,}**\"))\n",
    "df_eu.head()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c6df931e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 3 – Métricas principais\n",
    "ranking = df_eu.groupby('country')['points'].mean().round(2)\n",
    "top_pais = ranking.idxmax()\n",
    "top_pts  = ranking.max()\n",
    "melhor_qp = df_eu.groupby('country')['points_per_euro'].mean().idxmax()\n",
    "\n",
    "display(Markdown(f\"\"\"\n",
    "### Métricas Principais\n",
    "- **Melhor qualidade média**: {top_pais} → **{top_pts} pontos**  \n",
    "- **Melhor custo-benefício**: {melhor_qp}  \n",
    "- **Total de vinhos UE**: {len(df_eu):,}\n",
    "\"\"\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "681126c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 4 – Mapa Choropleth \n",
    "points_by_country = ranking.reset_index()\n",
    "\n",
    "fig = px.choropleth(points_by_country,\n",
    "                    locations=\"country\", locationmode=\"country names\",\n",
    "                    color=\"points\", hover_name=\"country\",\n",
    "                    color_continuous_scale=\"Reds\", range_color=(86,94),\n",
    "                    title=\"Pontuação Média por País da UE\")\n",
    "\n",
    "# Mostrar contexto geográfico (terras, oceano, costas) e limitar ao continente\n",
    "# reduzir projection_scale para não fazer zoom excessivo; usar ranges fixos para manter contexto\n",
    "fig.update_geos(scope=\"europe\",\n",
    "                lataxis_range=[34,74], lonaxis_range=[-30,45],\n",
    "                center=dict(lat=54, lon=15),\n",
    "                projection_scale=1.1,  # valor pequeno para evitar zoom excessivo\n",
    "                showcountries=True, showcoastlines=True, showland=True, showocean=True,\n",
    "                landcolor=\"rgb(240,240,240)\", oceancolor=\"rgb(210,230,255)\")\n",
    "\n",
    "fig.update_layout(height=600, margin={\"r\":0,\"t\":40,\"l\":0,\"b\":0})\n",
    "fig"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "32b82046",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 5 – Top 10 vinhos da UE\n",
    "\n",
    "top10 = df_eu.nlargest(10, 'points')[['title','country','winery','variety','points','price','province']]\n",
    "top10.index = range(1,11)\n",
    "top10.style.format({\"price\": \"€{:.0f}\", \"points\": \"{:.0f} pts\"})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9e97c663",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Célula 6 – Top 10 relação qualidade/preço da UE\n",
    "\n",
    "quality_price = df_eu.groupby('country')['points_per_euro'].mean().sort_values(ascending=False)\n",
    "\n",
    "plt.figure(figsize=(12,7))\n",
    "ax = quality_price.head(10).plot(kind='bar', color=sns.color_palette(\"magma\", 10))\n",
    "plt.title(\"Top 10 – Melhor Relação Qualidade/Preço (Pontos por Euro)\", fontsize=16, fontweight='bold')\n",
    "plt.ylabel(\"Pontos por Euro\")\n",
    "plt.xlabel(\"\")\n",
    "for i, v in enumerate(quality_price.head(10)):\n",
    "    ax.text(i, v + 0.01, f\"{v:.3f}\", ha='center', fontweight='bold')\n",
    "plt.tight_layout()\n",
    "# captura a figura antes de mostrar\n",
    "fig_qp = ax.get_figure()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "37cff5e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 7 – Boxplot dos 5 países com melhor pontuação média\n",
    "\n",
    "top5_countries = ranking.head(5).index.tolist()\n",
    "\n",
    "plt.figure(figsize=(12,7))\n",
    "ax = sns.boxplot(\n",
    "    data=df_eu[df_eu['country'].isin(top5_countries)],\n",
    "    x='country', y='points',\n",
    "    hue='country', palette='Set2', dodge=False\n",
    ")\n",
    "if ax.get_legend() is not None:\n",
    "    ax.legend_.remove()\n",
    "plt.title('Distribuição da Pontuação - Top 5 Países da UE', fontsize=16, fontweight='bold')\n",
    "plt.ylabel('Pontuação')\n",
    "plt.xlabel('')\n",
    "fig_box = plt.gcf()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7e5e290a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 8 – Relação preço vs pontuação (linha com média por preço)\n",
    "\n",
    "# calcula média e conta por preço; filtra preços com poucas observações\n",
    "points_by_price = df_eu.groupby('price')['points'].agg(mean='mean', count='count').reset_index()\n",
    "points_by_price = points_by_price[points_by_price['count'] >= 3].sort_values('price')\n",
    "\n",
    "plt.figure(figsize=(10,6))\n",
    "sns.lineplot(data=points_by_price, x='price', y='mean', color='crimson', lw=2)\n",
    "plt.xscale('log')  # opcional: mantém escala log para preços\n",
    "plt.xlabel('Preço (€)')\n",
    "plt.ylabel('Pontuação média')\n",
    "plt.title('Média da Pontuação por Preço (UE)')\n",
    "plt.tight_layout()\n",
    "fig_price = plt.gcf()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5e3870c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ...existing code...\n",
    "# Célula 9 – Mapa com marcadores proporcionais (tamanhos menores e normalizados)\n",
    "coordinates = {\n",
    "    'Portugal': [39.5, -8.2], 'Spain': [40.4, -3.7], 'France': [46.2, 2.2],\n",
    "    'Italy': [42.5, 12.1], 'Germany': [51.1, 10.4], 'Austria': [47.5, 13.2],\n",
    "    'Hungary': [47.1, 19.5], 'Romania': [45.9, 24.9], 'Greece': [39.0, 21.8],\n",
    "    'Bulgaria': [42.7, 25.4], 'Croatia': [45.1, 15.2], 'Slovenia': [46.1, 14.8],\n",
    "    'Belgium': [50.5, 4.0], 'Netherlands': [52.1, 5.3], 'Poland': [52.1, 19.2]\n",
    "}\n",
    "\n",
    "# cria o mapa base (aqui sem mostrar / salvar ainda)\n",
    "europe_map = folium.Map(location=[54, 15], zoom_start=4, tiles='CartoDB positron')\n",
    "\n",
    "# parâmetros de tamanho (ajusta aqui se quiseres ainda mais pequeno/grande)\n",
    "min_radius = 3\n",
    "max_radius = 10\n",
    "\n",
    "min_pts = ranking.min()\n",
    "max_pts = ranking.max()\n",
    "\n",
    "for country, coord in coordinates.items():\n",
    "    if country in ranking.index:\n",
    "        pts = float(ranking[country])\n",
    "        # normaliza pts para o intervalo [min_radius, max_radius]\n",
    "        if max_pts > min_pts:\n",
    "            radius = min_radius + (pts - min_pts) / (max_pts - min_pts) * (max_radius - min_radius)\n",
    "        else:\n",
    "            radius = (min_radius + max_radius) / 2\n",
    "        radius = max(2, round(radius, 1))  # garante um mínimo visível\n",
    "\n",
    "        folium.CircleMarker(\n",
    "            location=coord,\n",
    "            radius=radius,\n",
    "            popup=f\"<b>{country}</b><br>Pontuação média: {pts}\",\n",
    "            tooltip=f\"{country}: {pts} pts\",\n",
    "            color='crimson',\n",
    "            fill=True,\n",
    "            fill_color='crimson',\n",
    "            fill_opacity=0.7\n",
    "        ).add_to(europe_map)\n",
    "\n",
    "# salva e mostra apenas o mapa final com marcadores\n",
    "europe_map.save('folium_map.html')\n",
    "folium_html = 'folium_map.html'\n",
    "display(europe_map)\n",
    "# ...existing code..."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5c228557",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Célula 10: Guardar os objetos já calculados para o Streamlit usar\n",
    "import pickle\n",
    "import os\n",
    "\n",
    "# Exporta Plotly como dict e HTML interativo (se existir)\n",
    "fig_mapa_dict = None\n",
    "fig_mapa_html = None\n",
    "if 'fig' in globals() and fig is not None:\n",
    "    try:\n",
    "        fig_mapa_dict = fig.to_dict()\n",
    "        fig.write_html('fig_mapa.html')\n",
    "        fig_mapa_html = 'fig_mapa.html'\n",
    "    except Exception as e:\n",
    "        print(\"Aviso: não foi possível exportar 'fig' (plotly):\", e)\n",
    "\n",
    "# Guarda figuras matplotlib em PNG (se existirem)\n",
    "fig_qp_path = None\n",
    "fig_box_path = None\n",
    "fig_price_path = None\n",
    "\n",
    "try:\n",
    "    if 'fig_qp' in globals() and fig_qp is not None:\n",
    "        fig_qp_path = 'fig_qp.png'\n",
    "        fig_qp.savefig(fig_qp_path, bbox_inches='tight', dpi=150)\n",
    "except Exception as e:\n",
    "    print(\"Aviso: erro ao salvar fig_qp:\", e)\n",
    "\n",
    "try:\n",
    "    if 'fig_box' in globals() and fig_box is not None:\n",
    "        fig_box_path = 'fig_box.png'\n",
    "        fig_box.savefig(fig_box_path, bbox_inches='tight', dpi=150)\n",
    "except Exception as e:\n",
    "    print(\"Aviso: erro ao salvar fig_box:\", e)\n",
    "\n",
    "try:\n",
    "    if 'fig_price' in globals() and fig_price is not None:\n",
    "        fig_price_path = 'fig_price.png'\n",
    "        fig_price.savefig(fig_price_path, bbox_inches='tight', dpi=150)\n",
    "except Exception as e:\n",
    "    print(\"Aviso: erro ao salvar fig_price:\", e)\n",
    "\n",
    "# Folium já deve ter sido salvo na célula 9 como 'folium_map.html'\n",
    "folium_path = folium_html if ('folium_html' in globals() and folium_html and os.path.exists(folium_html)) else None\n",
    "\n",
    "# Objetos serializáveis para usar no Streamlit\n",
    "dados_para_app = {\n",
    "    'df_eu': df_eu,\n",
    "    'ranking': ranking,\n",
    "    'top_pais': top_pais,\n",
    "    'top_pts': top_pts,\n",
    "    'melhor_qp': melhor_qp,\n",
    "    'fig_mapa_dict': fig_mapa_dict,\n",
    "    'fig_mapa_html': fig_mapa_html,\n",
    "    'fig_qp_path': fig_qp_path,\n",
    "    'fig_box_path': fig_box_path,\n",
    "    'fig_price_path': fig_price_path,\n",
    "    'folium_html': folium_path,\n",
    "    'coordinates': coordinates,\n",
    "}\n",
    "\n",
    "with open('dados_notebook.pkl', 'wb') as f:\n",
    "    pickle.dump(dados_para_app, f)\n",
    "\n",
    "print(\"Dados guardados com sucesso! Agora podes correr o Streamlit →\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "33c02669",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[34m  Stopping...\u001b[0m\n",
      "^C\n"
     ]
    }
   ],
   "source": [
    "!streamlit run app.py\n",
    "# No caso de lhe pedir o email, basta rodar no terminal manualmente a primeira vez. Depois esta célula funcionará sempre.\\"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Projeto (3.14.0)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.14.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
